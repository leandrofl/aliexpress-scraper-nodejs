/**
 * @fileoverview Busca real de produtos no Mercado Livre com compara√ß√£o visual
 * @description Implementa busca real no Mercado Livre usando axios/cheerio + compara√ß√£o visual
 * com tratamento robusto de exce√ß√µes e integra√ß√£o com sistema de tradu√ß√£o
 * 
 * @author Sistema de Scraping AliExpress - Busca ML v2.0
 * @version 2.0.0 - Vers√£o otimizada com compara√ß√£o visual
 * @since 2024-01-01
 */

import axios from 'axios';
import axiosRetry from 'axios-retry';
import * as cheerio from 'cheerio';
import { compararImagensPorHash } from '../utils/comparador-imagens.js';
import { produtosSaoCompativeis } from '../utils/comparador-produtos.js';
import { calcularRiscoProduto, determinarMetodoValidacao, permiteValidacaoTextual } from '../utils/calculadora-risco.js';
import { compararSemantica, analisarProdutosSemantico, calcularEstatisticasPreco, calcularDesvioPreco } from '../utils/analisador-semantico.js';

// üõ° Melhoria 2: Configurar retry autom√°tico para falhas de rede
axiosRetry(axios, {
  retries: 3,
  retryDelay: axiosRetry.exponentialDelay,
  retryCondition: (error) => {
    return axiosRetry.isNetworkOrIdempotentRequestError(error) || 
           error.response?.status === 429 || 
           error.response?.status >= 500;
  }
});

// Busca os top 3 produtos no ML e retorna o mais parecido visualmente
export async function buscarMelhorProdutoML(produtoAli) {
  const termosBusca = gerarTermosDeBusca(produtoAli.nomeTraduzido || produtoAli.nome);
  const url = `https://lista.mercadolivre.com.br/${encodeURIComponent(termosBusca)}`;
  
  try {
    // üõ° Melhoria 2: Configura√ß√µes robustas para requisi√ß√µes
    const { data } = await axios.get(url, { 
      timeout: 15000,
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
        'Accept-Language': 'pt-BR,pt;q=0.9,en;q=0.8'
      }
    });
    const $ = cheerio.load(data);
    const itens = [];

    $('li.ui-search-layout__item').slice(0, 5).each((i, el) => {
      const nome = $(el).find('h2').text().trim();
      const precoTxt = $(el).find('.ui-search-price__second-line .price-tag-fraction').first().text();
      const imagem = $(el).find('img').attr('data-src') || $(el).find('img').attr('src');
      const link = $(el).find('a').attr('href');
      const preco = parseFloat(precoTxt.replace('.', '').replace(',', '.'));
      if (nome && preco && imagem) {
        itens.push({ nome, preco, imagem, link });
      }
    });

    let melhorProduto = null;
    let maiorSimilaridade = 0;
    const top3Produtos = []; // üì¶ Melhoria 1: Salvar top 3 produtos

    for (const item of itens) {
      try {
        const comp = await compararImagensPorHash(produtoAli.imagemURL, item.imagem);
        const produtoComSimilaridade = { 
          ...item, 
          similaridade: comp.similaridade,
          imagemComparada: true,
          fonteDeVerificacao: 'imagem',
          riscoImagem: false
        };
        
        // Adicionar ao array de top 3
        top3Produtos.push(produtoComSimilaridade);
        
        if (comp.similar && comp.similaridade > maiorSimilaridade) {
          maiorSimilaridade = comp.similaridade;
          melhorProduto = produtoComSimilaridade;
        }
      } catch (e) {
        console.warn('Erro na compara√ß√£o de imagem:', e.message);
        // Adicionar mesmo sem compara√ß√£o visual
        top3Produtos.push({ 
          ...item, 
          similaridade: 0,
          imagemComparada: false,
          fonteDeVerificacao: 'erro',
          riscoImagem: true
        });
      }
    }

    // üéØ FALLBACK TEXTUAL + SEM√ÇNTICO - Sugest√£o do ChatGPT aprimorada
    // Se n√£o encontrou match por imagem, tentar verifica√ß√£o sem√¢ntica
    if (!melhorProduto && itens.length > 0) {
      console.log('üîç Nenhum match por imagem encontrado. Tentando an√°lise sem√¢ntica...');
      
      // Calcular estat√≠sticas de pre√ßo dos top 3 (ChatGPT)
      const top3 = itens.slice(0, 3);
      const estatisticasPreco = calcularEstatisticasPreco(top3);
      
      console.log(`üìä Pre√ßo m√©dio ML (top 3): R$ ${estatisticasPreco.precoMedioML}`);
      
      // An√°lise sem√¢ntica dos produtos
      const analiseSemantica = await analisarProdutosSemantico(produtoAli, itens);
      
      if (analiseSemantica.melhorMatch && analiseSemantica.scoreSemantico >= 70) {
        console.log(`üß† Match sem√¢ntico encontrado: Score ${analiseSemantica.scoreSemantico}%`);
        
        const produtoSelecionado = analiseSemantica.melhorMatch;
        const desvioPreco = calcularDesvioPreco(produtoSelecionado.preco, produtoAli.preco);
        
        // Verificar se desvio de pre√ßo √© aceit√°vel (ChatGPT)
        if (desvioPreco <= 250) {
          console.log(`‚úÖ Desvio de pre√ßo aceit√°vel: ${desvioPreco}%`);
          
          // Criar dados para an√°lise de risco com novos campos
          const dadosParaRisco = {
            ...produtoAli,
            imagem_comparada: false,
            imagem_match: false,
            score_imagem: 0,
            score_semantico: analiseSemantica.scoreSemantico,
            score_texto: analiseSemantica.scoreSemantico, // Compatibilidade
            match_por_texto: true,
            aprovado_fallback_texto: true,
            desvio_preco: desvioPreco,
            preco_medio_ml: estatisticasPreco.precoMedioML,
            metodo_analise_titulo: analiseSemantica.metodoUsado,
            fonte_de_verificacao: 'semantico'
          };
          
          // Calcular risco final
          const analiseRisco = calcularRiscoProduto(dadosParaRisco);
          const metodoValidacao = determinarMetodoValidacao(dadosParaRisco);
          
          melhorProduto = {
            ...produtoSelecionado,
            similaridade: analiseSemantica.scoreSemantico,
            // Campos de controle de qualidade expandidos (ChatGPT)
            imagemComparada: false,
            fonteDeVerificacao: 'semantico',
            riscoImagem: true,
            metodoValidacaoMargem: metodoValidacao,
            scoreImagem: 0,
            imagemMatch: false,
            scoreTexto: analiseSemantica.scoreSemantico,
            scoreSemantico: analiseSemantica.scoreSemantico,
            matchPorTexto: true,
            aprovadoFallbackTexto: true,
            riscoFinal: analiseRisco.riscoFinal,
            pendenteRevisao: analiseRisco.pendenteRevisao,
            desvioPreco: desvioPreco,
            precoMedioML: estatisticasPreco.precoMedioML,
            metodoAnaliseTitulo: analiseSemantica.metodoUsado,
            
            // Dados de compatibilidade expandidos
            compatibilidadeTextual: {
              score: analiseSemantica.scoreSemantico,
              motivo: analiseSemantica.analiseCompleta?.motivo || 'An√°lise sem√¢ntica',
              detalhesRisco: analiseRisco.detalhesRisco,
              classificacao: analiseRisco.classificacaoRisco,
              metodoAnalise: analiseSemantica.metodoUsado,
              estatisticasPreco: estatisticasPreco
            }
          };
          
          console.log(`‚úÖ Produto aprovado via an√°lise sem√¢ntica`);
          console.log(`‚ö†Ô∏è Risco: ${analiseRisco.classificacaoRisco} (${analiseRisco.riscoFinal}%)`);
          
        } else {
          console.log(`‚ùå Desvio de pre√ßo muito alto: ${desvioPreco}% (m√°ximo 250%)`);
        }
      } else if (analiseSemantica.scoreSemantico > 0) {
        console.log(`‚ùå Score sem√¢ntico insuficiente: ${analiseSemantica.scoreSemantico}% (m√≠nimo 70%)`);
      }
      
      // Fallback para an√°lise textual tradicional se sem√¢ntica falhar
      if (!melhorProduto) {
        console.log('üîÑ Tentando fallback textual tradicional...');
        
        let melhorCompatibilidade = null;
        let maiorScore = 0;

        for (const item of itens) {
          try {
            // Verificar se categoria permite fallback textual
            if (!permiteValidacaoTextual(produtoAli)) {
              console.log('‚ùå Categoria n√£o permite fallback textual');
              continue;
            }
            
            // Verificar compatibilidade textual
            const compatibilidade = produtosSaoCompativeis(produtoAli, {
              nome: item.nome,
              preco: item.preco
            });

            if (compatibilidade.compat√≠vel && compatibilidade.score >= 60) {
              const desvioPreco = calcularDesvioPreco(item.preco, produtoAli.preco);
              
              // Validar desvio de pre√ßo (ChatGPT)
              if (desvioPreco <= 250 && compatibilidade.score > maiorScore) {
                maiorScore = compatibilidade.score;
                
                // Criar dados para an√°lise de risco
                const dadosParaRisco = {
                  ...produtoAli,
                  imagem_comparada: false,
                  imagem_match: false,
                  score_imagem: 0,
                  score_texto: compatibilidade.score,
                  match_por_texto: true,
                  aprovado_fallback_texto: true,
                  desvio_preco: desvioPreco,
                  preco_medio_ml: estatisticasPreco.precoMedioML,
                  metodo_analise_titulo: 'textual_fallback',
                  fonte_de_verificacao: 'texto'
                };
                
                // Calcular risco
                const analiseRisco = calcularRiscoProduto(dadosParaRisco);
                const metodoValidacao = determinarMetodoValidacao(dadosParaRisco);
                
                melhorCompatibilidade = {
                  ...item,
                  similaridade: compatibilidade.score,
                  // Campos de controle de qualidade expandidos
                  imagemComparada: false,
                  fonteDeVerificacao: 'texto',
                  riscoImagem: true,
                  metodoValidacaoMargem: metodoValidacao,
                  scoreImagem: 0,
                  imagemMatch: false,
                  scoreTexto: compatibilidade.score,
                  scoreSemantico: 0,
                  matchPorTexto: true,
                  aprovadoFallbackTexto: true,
                  riscoFinal: analiseRisco.riscoFinal,
                  pendenteRevisao: analiseRisco.pendenteRevisao,
                  desvioPreco: desvioPreco,
                  precoMedioML: estatisticasPreco.precoMedioML,
                  metodoAnaliseTitulo: 'textual_fallback',
                  
                  // Dados de compatibilidade expandidos
                  compatibilidadeTextual: {
                    ...compatibilidade,
                    detalhesRisco: analiseRisco.detalhesRisco,
                    classificacao: analiseRisco.classificacaoRisco,
                    estatisticasPreco: estatisticasPreco
                  }
                };
              }
            }
          } catch (compatError) {
            console.warn('Erro na verifica√ß√£o de compatibilidade:', compatError.message);
          }
        }

        if (melhorCompatibilidade) {
          melhorProduto = melhorCompatibilidade;
          console.log(`‚úÖ Fallback textual encontrou match: "${melhorProduto.nome}" (Score: ${maiorScore}%)`);
          console.log(`‚ö†Ô∏è ATEN√á√ÉO: Produto marcado com risco para revis√£o`);
        } else {
          console.log('‚ùå Nenhum produto compat√≠vel encontrado (imagem, sem√¢ntica ou textual)');
        }
      }
    }

    // Ordenar top 3 por similaridade
    top3Produtos.sort((a, b) => b.similaridade - a.similaridade);
    const top3Final = top3Produtos.slice(0, 3);

    return { 
      melhorProduto, 
      mlTop3Produtos: top3Final, // üì¶ Dados brutos dos top 3
      totalEncontrados: itens.length 
    };

  } catch (err) {
    console.error('Erro ao buscar ML:', err.message);
    return null;
  }
}

// Manter compatibilidade com a fun√ß√£o original
export async function buscarProdutosCompativeisML(browser, produtoAliExpress, opcoes = {}) {
  console.log('üîÑ Usando nova implementa√ß√£o de busca ML com axios/cheerio...');
  
  try {
    // Extrair primeira imagem do produto AliExpress
    const imagemURL = Array.isArray(produtoAliExpress.imagens) && produtoAliExpress.imagens.length > 0
      ? produtoAliExpress.imagens[0]
      : produtoAliExpress.imagemURL || null;

    if (!imagemURL) {
      console.warn('‚ö†Ô∏è Produto sem imagem para compara√ß√£o visual');
      return {
        encontrouProdutos: false,
        produtosCompat√≠veis: [],
        melhorMatch: null,
        erro: 'Sem imagem para compara√ß√£o'
      };
    }

    // Criar objeto produto compat√≠vel com a nova fun√ß√£o
    const produtoParaBusca = {
      nome: produtoAliExpress.nome,
      nomeTraduzido: produtoAliExpress.nomeTraduzido || produtoAliExpress.nome,
      imagemURL: imagemURL
    };

    const melhorProduto = await buscarMelhorProdutoML(produtoParaBusca);

    if (melhorProduto && melhorProduto.melhorProduto) {
      return {
        encontrouProdutos: true,
        produtosCompat√≠veis: melhorProduto.mlTop3Produtos || [],
        melhorMatch: melhorProduto.melhorProduto,
        totalEncontrados: melhorProduto.totalEncontrados || 0,
        termoBusca: gerarTermosDeBusca(produtoParaBusca.nomeTraduzido || produtoParaBusca.nome),
        erro: null
      };
    } else {
      return {
        encontrouProdutos: false,
        produtosCompat√≠veis: [],
        melhorMatch: null,
        totalEncontrados: 0,
        termoBusca: gerarTermosDeBusca(produtoParaBusca.nomeTraduzido || produtoParaBusca.nome),
        erro: 'Nenhum produto compat√≠vel encontrado'
      };
    }

  } catch (error) {
    console.error('‚ùå Erro na busca ML:', error.message);
    return {
      encontrouProdutos: false,
      produtosCompat√≠veis: [],
      melhorMatch: null,
      erro: error.message
    };
  }
}

// Fun√ß√£o legacy mantida por compatibilidade
export async function buscarProdutosMercadoLivre(browser, termoBusca, opcoes = {}) {
  console.log('üîÑ Redirecionando para nova implementa√ß√£o...');
  
  const produtoFake = {
    nome: termoBusca,
    nomeTraduzido: termoBusca,
    imagemURL: null // Ser√° tratado como sem imagem
  };

  const resultado = await buscarMelhorProdutoML(produtoFake);
  
  return {
    produtos: resultado ? [resultado] : [],
    termoBusca: termoBusca,
    paginaAtual: 1,
    totalProdutos: resultado ? 1 : 0
  };
}
